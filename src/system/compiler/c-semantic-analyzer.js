/**
 * C Semantic Analyzer for OrionRisc-128 C Compiler
 *
 * This program implements semantic analysis (type checking and symbol resolution)
 * for C programs as a machine language program that can be executed by the RISC processor.
 *
 * Phase 3 Component: Type checking and symbol resolution for the assembly-based C compiler
 *
 * Author: Kilo Code (OrionRisc-128 Project)
 * Date: October 19, 2025
 * Phase: 3 of 12-week development plan
 */

// ============================================================================
// C SEMANTIC ANALYZER - MACHINE LANGUAGE IMPLEMENTATION
// ============================================================================

/**
 * SEMANTIC ANALYSIS ERROR CODES
 */
const C_SEMANTIC_ERRORS = {
    UNDECLARED_VARIABLE: -1,     // Variable used but not declared
    UNDECLARED_FUNCTION: -2,     // Function called but not declared
    TYPE_MISMATCH: -3,          // Type incompatibility in expression
    INVALID_ASSIGNMENT: -4,      // Invalid assignment operation
    INVALID_OPERATION: -5,       // Invalid operation on types
    REDECLARED_SYMBOL: -6,       // Symbol declared multiple times
    SCOPE_ERROR: -7,            // Symbol scope violation
    PARAMETER_MISMATCH: -8,      // Function parameter count/type mismatch
    INVALID_RETURN: -9,         // Invalid return type or context
    ARRAY_BOUNDS: -10,          // Array access out of bounds
    POINTER_ERROR: -11,         // Invalid pointer operation
    STRUCT_ERROR: -12           // Invalid structure operation
};

/**
 * C TYPE SYSTEM
 */
const C_TYPES = {
    VOID: 0x0,          // void type
    INT: 0x1,           // int type
    CHAR: 0x2,          // char type
    POINTER: 0x3,       // pointer type (to any type)
    ARRAY: 0x4,         // array type
    FUNCTION: 0x5,      // function type
    STRUCT: 0x6         // structure type (future extension)
};

/**
 * TYPE MODIFIERS
 */
const C_TYPE_MODIFIERS = {
    NONE: 0x0,          // No modifiers
    CONST: 0x1,         // const qualifier
    VOLATILE: 0x2,      // volatile qualifier
    STATIC: 0x4,        // static storage class
    EXTERN: 0x8         // extern storage class
};

/**
 * SYMBOL TABLE ENTRY FORMAT
 * 32-bit format: TYPE(8) | MODIFIERS(4) | SCOPE(4) | SIZE(8) | ADDRESS(8)
 */
const SYMBOL_ENTRY_FORMAT = {
    TYPE: 24,           // Bits 31-24: Data type
    MODIFIERS: 20,      // Bits 23-20: Type modifiers
    SCOPE: 16,          // Bits 19-16: Scope level
    SIZE: 8,            // Bits 15-8: Size in bytes
    ADDRESS: 0          // Bits 7-0: Memory address or offset
};

/**
 * SCOPE LEVELS
 */
const C_SCOPE_LEVELS = {
    GLOBAL: 0x0,        // Global scope
    FUNCTION: 0x1,      // Function scope
    BLOCK: 0x2,         // Block scope
    MAX_SCOPE: 0xF      // Maximum scope depth
};

/**
 * SEMANTIC ANALYZER STATES
 */
const C_SEMANTIC_STATES = {
    START: 0x0,         // Initial state
    ANALYZING_PROGRAM: 0x1,    // Analyzing program structure
    ANALYZING_FUNCTION: 0x2,    // Analyzing function definition
    ANALYZING_DECLARATIONS: 0x3, // Analyzing declarations
    ANALYZING_STATEMENTS: 0x4,  // Analyzing statements
    ANALYZING_EXPRESSION: 0x5,  // Analyzing expression
    ANALYZING_TYPES: 0x6,      // Analyzing type compatibility
    ERROR: 0xF         // Error state
};

/**
 * MEMORY LAYOUT FOR C SEMANTIC ANALYZER
 *
 * 0x0000-0x0FFF: Program code (C semantic analyzer)
 * 0x1000-0x1FFF: AST buffer (input from parser)
 * 0x2000-0x2FFF: Symbol table (global and local symbols)
 * 0x3000-0x3FFF: Type table (type information storage)
 * 0x4000-0x40FF: Semantic state variables and pointers
 * 0x4100-0x41FF: Error reporting buffer
 * 0x4200-0x42FF: String table (for error messages)
 */

// ============================================================================
// MACHINE LANGUAGE PROGRAM - C SEMANTIC ANALYZER
// ============================================================================

/**
 * C Semantic Analyzer Machine Language Program
 *
 * This program performs semantic analysis on the AST generated by the C parser,
 * including type checking, symbol resolution, and scope management.
 *
 * Interface:
 * - R0: AST buffer address (input)
 * - R1: Symbol table address (output)
 * - R2: Type table address (output)
 * - R3: Current AST node index (input/output)
 * - R4: Error buffer address (output)
 * - Returns: Success (0) or error code (negative)
 */
const C_SEMANTIC_ANALYZER_PROGRAM = [
    // ========================================================================
    // INITIALIZATION PHASE
    // ========================================================================

    // Initialize state variables
    // R5 = current AST position
    // R6 = current symbol table position
    // R7 = current type table position
    // R8 = current scope level
    // R9 = semantic state (C_SEMANTIC_STATES.START)
    // R10 = current AST node data
    // R11 = symbol lookup result
    // R12 = type checking result
    // R13 = error code storage
    // R14 = temporary storage
    // R15 = string table position

    0x01000000, // LOAD R0, [R0 + 0]        ; R0 = AST buffer address
    0x01110000, // LOAD R1, [R1 + 0]        ; R1 = symbol table address
    0x01220000, // LOAD R2, [R2 + 0]        ; R2 = type table address
    0x01330000, // LOAD R3, [R3 + 0]        ; R3 = current AST node index
    0x01440000, // LOAD R4, [R4 + 0]        ; R4 = error buffer address

    // Initialize positions and state
    0x05550000, // ADD R5, R0, R0           ; R5 = 0 (AST position)
    0x06660000, // ADD R6, R0, R0           ; R6 = 0 (symbol table position)
    0x07770000, // ADD R7, R0, R0           ; R7 = 0 (type table position)
    0x08880000, // ADD R8, R0, R0           ; R8 = 0 (scope level = GLOBAL)
    0x09990000, // ADD R9, R0, R0           ; R9 = 0 (semantic state = START)
    0x0AA00000, // ADD R10, R0, R0          ; R10 = 0 (AST node data)
    0x0BB00000, // ADD R11, R0, R0          ; R11 = 0 (symbol lookup)
    0x0CC00000, // ADD R12, R0, R0          ; R12 = 0 (type check result)
    0x0DD00000, // ADD R13, R0, R0          ; R13 = 0 (error code)
    0x0EE00000, // ADD R14, R0, R0          ; R14 = 0 (temporary)
    0x0FF00000, // ADD R15, R0, R0          ; R15 = 0 (string position)

    // ========================================================================
    // MAIN SEMANTIC ANALYSIS LOOP
    // ========================================================================

    // main_loop:
    // Check if we've processed all AST nodes
    0xF0000000, // JUMP check_ast_end       ; Check for end of AST

    // get_current_node:
    // Read current AST node
    0x03150000, // ADD R14, R0, R5          ; R14 = AST address + position
    0x01AE0000, // LOAD R10, [R14 + 0]      ; R10 = current AST node data

    // Check for empty node (end of AST)
    0x03A00000, // SUB R14, R10, R0         ; Check if node is empty
    0xF4000000, // JUMP_EQ end_of_analysis  ; If empty, end analysis

    // ========================================================================
    // SEMANTIC STATE MACHINE
    // ========================================================================

    // Check current semantic state
    0x03990000, // SUB R14, R9, 0x0         ; Check if START state
    0xF4000000, // JUMP_EQ analyze_program  ; Analyze program

    0x03990001, // SUB R14, R9, 0x1         ; Check if ANALYZING_PROGRAM
    0xF4000000, // JUMP_EQ analyze_program_structure ; Analyze program structure

    0x03990002, // SUB R14, R9, 0x2         ; Check if ANALYZING_FUNCTION
    0xF4000000, // JUMP_EQ analyze_function ; Analyze function

    0x03990003, // SUB R14, R9, 0x3         ; Check if ANALYZING_DECLARATIONS
    0xF4000000, // JUMP_EQ analyze_declarations ; Analyze declarations

    0x03990004, // SUB R14, R9, 0x4         ; Check if ANALYZING_STATEMENTS
    0xF4000000, // JUMP_EQ analyze_statements ; Analyze statements

    0x03990005, // SUB R14, R9, 0x5         ; Check if ANALYZING_EXPRESSION
    0xF4000000, // JUMP_EQ analyze_expression ; Analyze expression

    0x03990006, // SUB R14, R9, 0x6         ; Check if ANALYZING_TYPES
    0xF4000000, // JUMP_EQ analyze_types    ; Analyze types

    // ========================================================================
    // AST NODE TYPE PROCESSING
    // ========================================================================

    // analyze_program:
    // Process PROGRAM node (root of AST)
    0xF0000000, // JUMP process_program_node

    // analyze_program_structure:
    // Process program-level declarations and definitions
    0xF0000000, // JUMP process_program_structure

    // analyze_function:
    // Process FUNCTION_DEF node
    0xF0000000, // JUMP process_function_node

    // analyze_declarations:
    // Process VARIABLE_DECL nodes
    0xF0000000, // JUMP process_declaration_node

    // analyze_statements:
    // Process statement nodes (if, while, return, etc.)
    0xF0000000, // JUMP process_statement_node

    // analyze_expression:
    // Process expression nodes (binary, unary, function calls)
    0xF0000000, // JUMP process_expression_node

    // analyze_types:
    // Process type-related analysis
    0xF0000000, // JUMP process_type_analysis

    // ========================================================================
    // SYMBOL TABLE MANAGEMENT
    // ========================================================================

    // lookup_symbol:
    // Look up symbol in symbol table
    // Input: R14 = symbol name address
    // Output: R11 = symbol entry address or 0 if not found

    // add_symbol:
    // Add symbol to symbol table
    // Input: R14 = symbol name address, R15 = type info, R8 = scope level
    // Output: R11 = symbol entry address

    // ========================================================================
    // TYPE CHECKING OPERATIONS
    // ========================================================================

    // check_type_compatibility:
    // Check if two types are compatible for operation
    // Input: R12 = left type, R13 = right type
    // Output: R14 = compatibility result (0 = compatible, negative = error)

    // get_expression_type:
    // Determine type of expression
    // Input: R10 = expression AST node
    // Output: R12 = expression type

    // ========================================================================
    // SCOPE MANAGEMENT
    // ========================================================================

    // enter_scope:
    // Enter new scope level
    0x08881001, // ADD R8, R8, 1            ; Increment scope level

    // exit_scope:
    // Exit current scope level
    0x088810FF, // ADD R8, R8, -1           ; Decrement scope level

    // ========================================================================
    // ERROR REPORTING
    // ========================================================================

    // report_error:
    // Report semantic error
    // Input: R13 = error code, R14 = AST node address, R15 = additional info

    // ========================================================================
    // LOOP CONTROL
    // ========================================================================

    // next_node:
    // Move to next AST node
    0x05551004, // ADD R5, R5, 4            ; Next AST node position
    0xF0000000, // JUMP main_loop          ; Continue analysis

    // check_ast_end:
    // Check if we've reached the end of AST
    0xF0000000, // JUMP get_current_node    ; Continue processing

    // end_of_analysis:
    // Analysis complete
    0x00D00000, // ADD R0, R13, R0          ; Return error code (0 = success)
    0xFF000000  // HALT                    ; End of program
];

// ============================================================================
// ASSEMBLY SOURCE CODE FOR THE C SEMANTIC ANALYZER
// ============================================================================

/**
 * Assembly Source Code Representation
 *
 * This is how the C semantic analyzer program would appear in assembly language.
 * This serves as documentation and can be used for testing the assembler.
 */
const C_SEMANTIC_ANALYZER_ASSEMBLY = `
; ============================================================================
; C SEMANTIC ANALYZER - ASSEMBLY SOURCE
; ============================================================================

; OrionRisc-128 Assembly Language
; Semantic Analysis for C Type Checking and Symbol Resolution
; Phase 3: Assembly-based C Compiler Component

.text
.global _start

_start:
    ; Initialize semantic analyzer state
    LOAD R5, 0              ; AST position = 0
    LOAD R6, 0              ; Symbol table position = 0
    LOAD R7, 0              ; Type table position = 0
    LOAD R8, SCOPE_GLOBAL    ; Current scope = GLOBAL
    LOAD R9, STATE_START     ; Semantic state = START
    LOAD R13, 0             ; Error code = 0

main_loop:
    ; Check for end of AST
    CALL check_ast_end
    JUMP_EQ end_of_analysis

    ; Get current AST node
    CALL get_current_node

    ; State-based processing
    SUB R14, R9, STATE_START
    JUMP_EQ analyze_program

    SUB R14, R9, STATE_ANALYZING_PROGRAM
    JUMP_EQ analyze_program_structure

    SUB R14, R9, STATE_ANALYZING_FUNCTION
    JUMP_EQ analyze_function

    SUB R14, R9, STATE_ANALYZING_DECLARATIONS
    JUMP_EQ analyze_declarations

    SUB R14, R9, STATE_ANALYZING_STATEMENTS
    JUMP_EQ analyze_statements

    SUB R14, R9, STATE_ANALYZING_EXPRESSION
    JUMP_EQ analyze_expression

    SUB R14, R9, STATE_ANALYZING_TYPES
    JUMP_EQ analyze_types

    ; Continue to next node
    CALL next_node
    JUMP main_loop

end_of_analysis:
    ; Return success/error code
    LOAD R0, R13
    RET

; ============================================================================
; AST NODE PROCESSING
; ============================================================================

get_current_node:
    ; Input: R5 = AST position, R0 = AST buffer address
    ; Output: R10 = current AST node data

    ; Calculate node address
    SHIFT_LEFT R14, R5, 2   ; R14 = position * 4
    ADD R14, R14, R0        ; R14 = AST buffer + offset
    LOAD R10, [R14]         ; R10 = AST node data
    RET

next_node:
    ; Move to next AST node
    ADD R5, R5, 1
    RET

check_ast_end:
    ; Check if we've reached end of AST
    ; Input: R10 = current node data
    ; Output: R14 = 1 if end, 0 if not

    SUB R14, R10, 0         ; Check if node is empty
    JUMP_EQ is_end
    LOAD R14, 0             ; Not end
    RET

is_end:
    LOAD R14, 1             ; Is end
    RET

; ============================================================================
; PROGRAM ANALYSIS
; ============================================================================

analyze_program:
    ; Process PROGRAM node (root of AST)

    ; Set state to analyzing program
    LOAD R9, STATE_ANALYZING_PROGRAM

    ; Create global scope
    CALL enter_scope

    ; Process program children (function definitions and declarations)
    CALL process_program_children

    ; Exit global scope
    CALL exit_scope

    RET

process_program_children:
    ; Process all children of program node
    ; This would traverse the AST and process each top-level declaration

    RET

; ============================================================================
; FUNCTION ANALYSIS
; ============================================================================

analyze_function:
    ; Process FUNCTION_DEF node

    ; Enter function scope
    CALL enter_scope
    LOAD R9, STATE_ANALYZING_FUNCTION

    ; Analyze function signature (return type, parameters)
    CALL analyze_function_signature

    ; Analyze function body
    CALL analyze_function_body

    ; Exit function scope
    CALL exit_scope

    RET

analyze_function_signature:
    ; Analyze function return type and parameters

    ; Check return type validity
    CALL check_return_type

    ; Process parameter list
    CALL analyze_parameters

    RET

analyze_function_body:
    ; Analyze statements in function body

    LOAD R9, STATE_ANALYZING_STATEMENTS
    ; Process statement list

    RET

; ============================================================================
; DECLARATION ANALYSIS
; ============================================================================

analyze_declarations:
    ; Process VARIABLE_DECL nodes

    LOAD R9, STATE_ANALYZING_DECLARATIONS

    ; Check for redeclaration
    CALL check_redeclaration

    ; Add symbol to symbol table
    CALL add_symbol_to_table

    ; Check initializer if present
    CALL analyze_initializer

    RET

; ============================================================================
; STATEMENT ANALYSIS
; ============================================================================

analyze_statements:
    ; Process statement nodes

    LOAD R9, STATE_ANALYZING_STATEMENTS

    ; Analyze statement based on type
    ; (if, while, return, expression statement, etc.)

    RET

; ============================================================================
; EXPRESSION ANALYSIS
; ============================================================================

analyze_expression:
    ; Process expression nodes

    LOAD R9, STATE_ANALYZING_EXPRESSION

    ; Determine expression type
    CALL get_expression_type

    ; Check for type errors
    CALL check_expression_types

    RET

; ============================================================================
; TYPE ANALYSIS
; ============================================================================

analyze_types:
    ; Process type-related analysis

    LOAD R9, STATE_ANALYZING_TYPES

    ; Check type compatibility
    CALL check_type_compatibility

    RET

; ============================================================================
; SYMBOL TABLE MANAGEMENT
; ============================================================================

enter_scope:
    ; Enter new scope level
    ADD R8, R8, 1
    RET

exit_scope:
    ; Exit current scope level
    SUB R8, R8, 1

    ; Remove symbols from current scope
    CALL remove_scope_symbols

    RET

remove_scope_symbols:
    ; Remove all symbols from current scope level
    ; This would traverse symbol table and remove symbols with current scope

    RET

lookup_symbol:
    ; Look up symbol in symbol table
    ; Input: R14 = symbol name address
    ; Output: R11 = symbol entry address or 0 if not found

    ; Hash symbol name
    CALL hash_symbol_name

    ; Search symbol table for matching hash and name
    CALL search_symbol_table

    RET

add_symbol_to_table:
    ; Add symbol to symbol table
    ; Input: R14 = symbol name address, R15 = type info, R8 = scope level

    ; Check if symbol already exists in current scope
    CALL lookup_symbol
    SUB R11, R11, 0
    JUMP_NE symbol_exists_error

    ; Create new symbol entry
    CALL create_symbol_entry

    ; Store in symbol table
    CALL store_symbol_entry

    RET

symbol_exists_error:
    ; Report redeclaration error
    LOAD R13, ERROR_REDECLARED_SYMBOL
    RET

; ============================================================================
; TYPE CHECKING
; ============================================================================

check_type_compatibility:
    ; Check if two types are compatible
    ; Input: R12 = left type, R13 = right type
    ; Output: R14 = 0 if compatible, negative if not

    ; Compare type values
    SUB R14, R12, R13
    JUMP_EQ types_compatible

    ; Check for special cases (int/char compatibility, pointer compatibility)
    CALL check_special_compatibility

types_compatible:
    LOAD R14, 0
    RET

check_special_compatibility:
    ; Check special type compatibility cases

    ; int and char are compatible in some contexts
    SUB R14, R12, TYPE_INT
    JUMP_EQ check_int_char
    SUB R14, R13, TYPE_INT
    JUMP_EQ check_int_char

    ; Pointer compatibility rules
    CALL check_pointer_compatibility

    ; Default: incompatible
    LOAD R14, ERROR_TYPE_MISMATCH
    RET

check_int_char:
    ; Check if one type is int and other is char
    SUB R14, R12, TYPE_CHAR
    JUMP_EQ int_char_compatible
    SUB R14, R13, TYPE_CHAR
    JUMP_EQ int_char_compatible

    LOAD R14, ERROR_TYPE_MISMATCH
    RET

int_char_compatible:
    LOAD R14, 0
    RET

check_pointer_compatibility:
    ; Check pointer compatibility rules

    ; Both must be pointers or one must be pointer and other null
    SUB R14, R12, TYPE_POINTER
    JUMP_EQ check_right_pointer
    LOAD R14, ERROR_TYPE_MISMATCH
    RET

check_right_pointer:
    SUB R14, R13, TYPE_POINTER
    JUMP_EQ pointers_compatible

    ; Check if right side is integer 0 (null pointer)
    SUB R14, R13, 0
    JUMP_EQ null_pointer_compatible

    LOAD R14, ERROR_TYPE_MISMATCH
    RET

pointers_compatible:
null_pointer_compatible:
    LOAD R14, 0
    RET

get_expression_type:
    ; Determine type of expression
    ; Input: R10 = expression AST node
    ; Output: R12 = expression type

    ; Extract node type from AST node
    CALL get_node_type

    ; Process based on expression type
    SUB R14, R11, NODE_IDENTIFIER
    JUMP_EQ get_identifier_type

    SUB R14, R11, NODE_CONSTANT
    JUMP_EQ get_constant_type

    SUB R14, R11, NODE_BINARY_EXPRESSION
    JUMP_EQ get_binary_expression_type

    SUB R14, R11, NODE_UNARY_EXPRESSION
    JUMP_EQ get_unary_expression_type

    SUB R14, R11, NODE_FUNCTION_CALL
    JUMP_EQ get_function_call_type

    ; Default: unknown type
    LOAD R12, TYPE_VOID
    RET

get_identifier_type:
    ; Get type of identifier from symbol table

    ; Look up identifier in symbol table
    CALL lookup_symbol

    ; Extract type from symbol entry
    CALL extract_symbol_type

    RET

get_constant_type:
    ; Determine type of constant

    ; Check if integer or character constant
    ; For now, assume all constants are int
    LOAD R12, TYPE_INT
    RET

get_binary_expression_type:
    ; Get type of binary expression

    ; Get types of left and right operands
    CALL get_left_operand_type
    LOAD R12, R14           ; Left type

    CALL get_right_operand_type
    LOAD R13, R14           ; Right type

    ; Apply binary operator type rules
    CALL apply_binary_type_rules

    RET

get_unary_expression_type:
    ; Get type of unary expression

    ; Get type of operand
    CALL get_operand_type

    ; Apply unary operator type rules
    CALL apply_unary_type_rules

    RET

get_function_call_type:
    ; Get return type of function call

    ; Look up function in symbol table
    CALL lookup_function_symbol

    ; Extract return type from function entry
    CALL extract_function_return_type

    RET

; ============================================================================
; ERROR REPORTING
; ============================================================================

report_error:
    ; Report semantic error
    ; Input: R13 = error code, R14 = AST node address, R15 = additional info

    ; Store error in error buffer
    STORE [R4], R13         ; Error code
    ADD R4, R4, 1
    STORE [R4], R14         ; AST node address
    ADD R4, R4, 1
    STORE [R4], R15         ; Additional info
    ADD R4, R4, 1

    RET

; ============================================================================
; UTILITY FUNCTIONS
; ============================================================================

get_node_type:
    ; Extract node type from AST node data
    ; Input: R10 = AST node data
    ; Output: R11 = node type

    SHIFT_RIGHT R11, R10, 24
    AND R11, R11, 0xFF
    RET

hash_symbol_name:
    ; Simple hash function for symbol names
    ; Input: R14 = symbol name address
    ; Output: R11 = hash value

    ; Simple djb2 hash algorithm
    LOAD R11, 5381          ; Initial hash value

hash_loop:
    ; Read character from name
    LOAD R15, [R14]
    ADD R14, R14, 1

    ; Check for end of string
    SUB R15, R15, 0
    JUMP_EQ hash_end

    ; hash = ((hash << 5) + hash) + c
    SHIFT_LEFT R11, R11, 5
    ADD R11, R11, R15

    JUMP hash_loop

hash_end:
    RET

; ============================================================================
; DATA SECTION
; ============================================================================

.data
    ; Semantic analyzer states
    STATE_START:                .equ 0x0
    STATE_ANALYZING_PROGRAM:    .equ 0x1
    STATE_ANALYZING_FUNCTION:   .equ 0x2
    STATE_ANALYZING_DECLARATIONS: .equ 0x3
    STATE_ANALYZING_STATEMENTS: .equ 0x4
    STATE_ANALYZING_EXPRESSION: .equ 0x5
    STATE_ANALYZING_TYPES:      .equ 0x6
    STATE_ERROR:                .equ 0xF

    ; Scope levels
    SCOPE_GLOBAL:               .equ 0x0
    SCOPE_FUNCTION:             .equ 0x1
    SCOPE_BLOCK:                .equ 0x2

    ; C types
    TYPE_VOID:                  .equ 0x0
    TYPE_INT:                   .equ 0x1
    TYPE_CHAR:                  .equ 0x2
    TYPE_POINTER:               .equ 0x3
    TYPE_ARRAY:                 .equ 0x4
    TYPE_FUNCTION:              .equ 0x5
    TYPE_STRUCT:                .equ 0x6

    ; Error codes
    ERROR_UNDECLARED_VARIABLE:  .equ -1
    ERROR_UNDECLARED_FUNCTION:  .equ -2
    ERROR_TYPE_MISMATCH:        .equ -3
    ERROR_INVALID_ASSIGNMENT:   .equ -4
    ERROR_INVALID_OPERATION:    .equ -5
    ERROR_REDECLARED_SYMBOL:    .equ -6
    ERROR_SCOPE_ERROR:          .equ -7
    ERROR_PARAMETER_MISMATCH:   .equ -8
    ERROR_INVALID_RETURN:       .equ -9
    ERROR_ARRAY_BOUNDS:         .equ -10
    ERROR_POINTER_ERROR:        .equ -11
    ERROR_STRUCT_ERROR:         .equ -12

    ; AST node types (from parser)
    NODE_PROGRAM:               .equ 0x0
    NODE_FUNCTION_DEF:          .equ 0x2
    NODE_VARIABLE_DECL:         .equ 0x3
    NODE_IF_STATEMENT:          .equ 0x6
    NODE_WHILE_STATEMENT:       .equ 0x7
    NODE_RETURN_STATEMENT:      .equ 0x9
    NODE_EXPRESSION_STATEMENT:  .equ 0xA
    NODE_BINARY_EXPRESSION:     .equ 0xB
    NODE_UNARY_EXPRESSION:      .equ 0xC
    NODE_IDENTIFIER:            .equ 0xD
    NODE_CONSTANT:              .equ 0xE
    NODE_FUNCTION_CALL:         .equ 0x10
    NODE_ASSIGNMENT:            .equ 0x11
`;

// ============================================================================
// JAVASCRIPT INTERFACE AND TESTING
// ============================================================================

/**
 * CSemanticAnalyzer class for integration with the OrionRisc-128 system
 */
class CSemanticAnalyzer {
    constructor(mmu, cpu) {
        this.mmu = mmu;
        this.cpu = cpu;
        this.program = C_SEMANTIC_ANALYZER_PROGRAM;
    }

    /**
     * Load the C semantic analyzer program into memory
     * @param {number} startAddress - Memory address to load program (default: 0x0000)
     */
    loadProgram(startAddress = 0x0000) {
        console.log(`Loading C semantic analyzer program at address 0x${startAddress.toString(16)}`);
        this.cpu.loadProgram(this.program, startAddress);
    }

    /**
     * Perform semantic analysis on AST
     * @param {number} astAddress - Memory address of AST buffer (default: 0x1000)
     * @param {number} symbolTableAddress - Memory address for symbol table (default: 0x2000)
     * @param {number} typeTableAddress - Memory address for type table (default: 0x3000)
     * @param {number} errorAddress - Memory address for error buffer (default: 0x4000)
     * @param {number} astNodeIndex - Current AST node index (default: 0)
     * @returns {Object} Semantic analysis result
     */
    analyze(astAddress = 0x1000, symbolTableAddress = 0x2000, typeTableAddress = 0x3000, errorAddress = 0x4000, astNodeIndex = 0) {
        console.log(`Performing semantic analysis on AST`);

        // Set up CPU registers for C semantic analyzer
        this.cpu.setRegister(0, astAddress);         // R0 = AST buffer address
        this.cpu.setRegister(1, symbolTableAddress); // R1 = symbol table address
        this.cpu.setRegister(2, typeTableAddress);   // R2 = type table address
        this.cpu.setRegister(3, astNodeIndex);       // R3 = current AST node index
        this.cpu.setRegister(4, errorAddress);       // R4 = error buffer address

        // Execute C semantic analyzer program
        const instructionsExecuted = this.cpu.run();

        console.log(`C semantic analyzer executed ${instructionsExecuted} instructions`);

        // Read results from memory
        const symbolTable = this.readSymbolTable(symbolTableAddress);
        const typeTable = this.readTypeTable(typeTableAddress);
        const errors = this.readErrors(errorAddress);

        // Get result from R0 (success/error code)
        const result = this.cpu.getRegister(0);

        return {
            success: result >= 0,
            errorCode: result < 0 ? result : 0,
            symbolTable: symbolTable,
            typeTable: typeTable,
            errors: errors,
            instructionsExecuted: instructionsExecuted,
            astNodeIndex: this.cpu.getRegister(3)
        };
    }

    /**
     * Read symbol table from memory
     * @param {number} symbolTableAddress - Memory address of symbol table
     * @returns {Object} Symbol table structure
     */
    readSymbolTable(symbolTableAddress) {
        const symbols = [];

        // Read symbol entries until we find empty memory
        for (let offset = 0; offset < 0x1000; offset += 4) {
            const entry = this.mmu.readWord(symbolTableAddress + offset);

            if (entry === 0) {
                break; // End of symbol table
            }

            // Parse symbol entry format: TYPE(8) | MODIFIERS(4) | SCOPE(4) | SIZE(8) | ADDRESS(8)
            const type = (entry >> 24) & 0xFF;
            const modifiers = (entry >> 20) & 0xF;
            const scope = (entry >> 16) & 0xF;
            const size = (entry >> 8) & 0xFF;
            const address = entry & 0xFF;

            symbols.push({
                type: type,
                modifiers: modifiers,
                scope: scope,
                size: size,
                address: address,
                entryAddress: symbolTableAddress + offset
            });
        }

        return {
            symbols: symbols,
            address: symbolTableAddress,
            size: symbols.length
        };
    }

    /**
     * Read type table from memory
     * @param {number} typeTableAddress - Memory address of type table
     * @returns {Object} Type table structure
     */
    readTypeTable(typeTableAddress) {
        const types = [];

        // Read type entries until we find empty memory
        for (let offset = 0; offset < 0x1000; offset += 4) {
            const entry = this.mmu.readWord(typeTableAddress + offset);

            if (entry === 0) {
                break; // End of type table
            }

            types.push({
                entry: entry,
                address: typeTableAddress + offset
            });
        }

        return {
            types: types,
            address: typeTableAddress,
            size: types.length
        };
    }

    /**
     * Read errors from memory
     * @param {number} errorAddress - Memory address of error buffer
     * @returns {Array} Array of error objects
     */
    readErrors(errorAddress) {
        const errors = [];

        // Read error entries (error code, AST node address, additional info)
        for (let offset = 0; offset < 0x1000; offset += 3) {
            const errorCode = this.mmu.readByte(errorAddress + offset);
            const astNodeAddr = this.mmu.readByte(errorAddress + offset + 1);
            const additionalInfo = this.mmu.readByte(errorAddress + offset + 2);

            if (errorCode === 0) {
                break; // End of errors
            }

            errors.push({
                code: errorCode,
                astNodeAddress: astNodeAddr,
                additionalInfo: additionalInfo,
                address: errorAddress + offset
            });
        }

        return errors;
    }

    /**
     * Get semantic error name for debugging
     * @param {number} errorCode - Error code value
     * @returns {string} Error name
     */
    static getSemanticErrorName(errorCode) {
        const names = Object.keys(C_SEMANTIC_ERRORS);
        for (const name of names) {
            if (C_SEMANTIC_ERRORS[name] === errorCode) {
                return name;
            }
        }
        return 'UNKNOWN_ERROR';
    }

    /**
     * Get type name for debugging
     * @param {number} type - Type value
     * @returns {string} Type name
     */
    static getTypeName(type) {
        const names = Object.keys(C_TYPES);
        for (const name of names) {
            if (C_TYPES[name] === type) {
                return name;
            }
        }
        return 'UNKNOWN_TYPE';
    }
}

// ============================================================================
// INTEGRATION WITH C COMPILER PIPELINE
// ============================================================================

/**
 * Complete C compiler pipeline: lexical analysis + parsing + semantic analysis
 */
class CCompiler {
    constructor(mmu, cpu) {
        this.mmu = mmu;
        this.cpu = cpu;
        this.lexer = new CLexicalAnalyzer(mmu, cpu);
        this.parser = new CParser(mmu, cpu);
        this.semanticAnalyzer = new CSemanticAnalyzer(mmu, cpu);
    }

    /**
     * Compile C source code to semantically analyzed AST
     * @param {string} sourceCode - C source code
     * @param {number} sourceAddress - Source buffer address (default: 0x1000)
     * @param {number} tokenAddress - Token buffer address (default: 0x2000)
     * @param {number} astAddress - AST buffer address (default: 0x3000)
     * @param {number} stringAddress - String table address (default: 0x4000)
     * @param {number} symbolTableAddress - Symbol table address (default: 0x5000)
     * @param {number} typeTableAddress - Type table address (default: 0x6000)
     * @param {number} errorAddress - Error buffer address (default: 0x7000)
     * @returns {Object} Complete compilation result
     */
    compile(sourceCode, sourceAddress = 0x1000, tokenAddress = 0x2000, astAddress = 0x3000, stringAddress = 0x4000, symbolTableAddress = 0x5000, typeTableAddress = 0x6000, errorAddress = 0x7000) {
        console.log(`Compiling C source code with semantic analysis (${sourceCode.length} characters)`);

        // Step 1: Lexical analysis
        console.log('Step 1: Lexical analysis...');
        this.lexer.loadProgram(0x0000);
        const lexResult = this.lexer.tokenize(sourceCode, sourceAddress, tokenAddress, stringAddress);

        if (lexResult.tokenCount === 0) {
            return {
                success: false,
                error: 'No tokens generated by lexical analyzer',
                stage: 'lexical_analysis'
            };
        }

        console.log(`Generated ${lexResult.tokenCount} tokens`);

        // Step 2: Parsing
        console.log('Step 2: Parsing tokens into AST...');
        this.parser.loadProgram(0x8000); // Load parser after lexer
        const parseResult = this.parser.parse(tokenAddress, astAddress, stringAddress, 0);

        if (!parseResult.success) {
            return {
                success: false,
                error: `Parsing failed with error code ${parseResult.errorCode}`,
                stage: 'parsing',
                tokens: lexResult.tokenCount,
                instructions: parseResult.instructionsExecuted
            };
        }

        console.log(`Parsing successful. AST size: ${parseResult.ast.size} nodes`);

        // Step 3: Semantic analysis
        console.log('Step 3: Semantic analysis...');
        this.semanticAnalyzer.loadProgram(0x9000); // Load semantic analyzer after parser
        const semanticResult = this.semanticAnalyzer.analyze(astAddress, symbolTableAddress, typeTableAddress, errorAddress, 0);

        if (!semanticResult.success) {
            return {
                success: false,
                error: `Semantic analysis failed with error code ${semanticResult.errorCode}`,
                stage: 'semantic_analysis',
                tokens: lexResult.tokenCount,
                astNodes: parseResult.ast.size,
                instructions: semanticResult.instructionsExecuted,
                errors: semanticResult.errors
            };
        }

        console.log(`Semantic analysis successful. Symbols: ${semanticResult.symbolTable.size}`);

        return {
            success: true,
            tokens: lexResult.tokenCount,
            astNodes: parseResult.ast.size,
            symbols: semanticResult.symbolTable.size,
            types: semanticResult.typeTable.size,
            instructions: parseResult.instructionsExecuted + semanticResult.instructionsExecuted,
            stringTable: lexResult.stringTable,
            symbolTable: semanticResult.symbolTable,
            typeTable: semanticResult.typeTable,
            errors: semanticResult.errors
        };
    }
}

// ============================================================================
// EXAMPLE USAGE AND TESTING
// ============================================================================

/**
 * Example C source code for testing semantic analysis
 */
const EXAMPLE_C_CODE_SEMANTIC = `
/* Example C program for testing semantic analysis */
#include <stdio.h>

int global_var = 42;

int add_numbers(int a, int b) {
    int result;
    char c;

    result = a + b;  // Valid: int + int

    c = 'A';         // Valid: char = char

    // c = result;   // Invalid: char = int (uncomment to test error)

    return result;
}

void test_function(void) {
    int x = 10;
    int y;

    y = x + 5;       // Valid

    // y = "hello";  // Invalid: int = char* (uncomment to test error)
}

int main(void) {
    int sum;
    char* message;

    sum = add_numbers(10, 20);  // Valid function call

    // sum = add_numbers(10);   // Invalid: wrong parameter count

    message = "Hello";          // Valid: char* = string literal

    if (sum > 0) {              // Valid: int > int
        printf("Positive\\n");
    }

    return 0;
}
`;

/**
 * Test the complete C compiler pipeline with semantic analysis
 */
function testCCompilerWithSemanticAnalysis() {
    console.log('=== C COMPILER WITH SEMANTIC ANALYSIS TEST ===');

    console.log('Example C code for semantic analysis testing:');
    console.log(EXAMPLE_C_CODE_SEMANTIC);

    console.log('\\nExpected semantic analysis results:');
    console.log('- Global variable declarations: global_var (int)');
    console.log('- Function declarations: add_numbers, test_function, main');
    console.log('- Type checking: int + int, char = char, function calls');
    console.log('- Symbol resolution: variable and function references');
    console.log('- Scope management: global vs local symbols');

    console.log('\\nPotential semantic errors to detect:');
    console.log('- Type mismatches: int = char*, char = int');
    console.log('- Undeclared variables: using variables before declaration');
    console.log('- Function call errors: wrong parameter count or types');
    console.log('- Scope errors: accessing local variables from wrong scope');

    console.log('\\nC semantic analyzer implementation ready for Phase 3 integration');
}

/**
 * Test semantic analyzer with mock AST
 */
function testSemanticAnalyzerWithMockAST() {
    console.log('=== SEMANTIC ANALYZER MOCK AST TEST ===');

    console.log('Mock AST for semantic analysis testing:');
    console.log('- PROGRAM');
    console.log('  - FUNCTION_DEF (int main)');
    console.log('    - VARIABLE_DECL (int x)');
    console.log('    - ASSIGNMENT (x = 42)');
    console.log('    - RETURN_STATEMENT (x)');

    console.log('\\nExpected semantic analysis:');
    console.log('- Symbol table: main (function), x (int variable)');
    console.log('- Type checking: int = int (valid)');
    console.log('- Return type: int function returns int (valid)');
    console.log('- Scope: x accessible in function scope (valid)');

    console.log('\\nSemantic analyzer ready for integration testing');
}

// ============================================================================
// VALIDATION AND TESTING FUNCTIONS
// ============================================================================

/**
 * Validate semantic analysis results
 * @param {Object} result - Semantic analysis result
 * @returns {boolean} True if results are valid
 */
function validateSemanticAnalysis(result) {
    if (!result || !result.success) {
        console.log('Semantic analysis validation failed: Analysis was not successful');
        return false;
    }

    if (!result.symbolTable || result.symbolTable.size === 0) {
        console.log('Semantic analysis validation failed: No symbols found');
        return false;
    }

    if (result.errors && result.errors.length > 0) {
        console.log(`Semantic analysis validation: Found ${result.errors.length} errors (expected for testing)`);
    }

    console.log('Semantic analysis validation passed');
    return true;
}

/**
 * Print semantic analysis results for debugging
 * @param {Object} result - Semantic analysis result
 */
function printSemanticAnalysisResults(result) {
    console.log('\\n=== SEMANTIC ANALYSIS RESULTS ===');

    if (result.success) {
        console.log('✓ Semantic analysis successful');

        if (result.symbolTable) {
            console.log(`\\nSymbol Table (${result.symbolTable.size} symbols):`);
            result.symbolTable.symbols.forEach((symbol, index) => {
                console.log(`  ${index}: Type=${CSemanticAnalyzer.getTypeName(symbol.type)}, ` +
                          `Scope=${symbol.scope}, Size=${symbol.size}, Address=0x${symbol.address.toString(16)}`);
            });
        }

        if (result.typeTable && result.typeTable.size > 0) {
            console.log(`\\nType Table (${result.typeTable.size} types):`);
            result.typeTable.types.forEach((type, index) => {
                console.log(`  ${index}: 0x${type.entry.toString(16)}`);
            });
        }
    } else {
        console.log('✗ Semantic analysis failed');
        console.log(`Error code: ${result.errorCode} (${CSemanticAnalyzer.getSemanticErrorName(result.errorCode)})`);
    }

    if (result.errors && result.errors.length > 0) {
        console.log(`\\nErrors found (${result.errors.length}):`);
        result.errors.forEach((error, index) => {
            console.log(`  ${index}: ${CSemanticAnalyzer.getSemanticErrorName(error.code)} ` +
                      `at AST node 0x${error.astNodeAddress.toString(16)}`);
        });
    }

    console.log(`\\nInstructions executed: ${result.instructionsExecuted}`);
}

// Export for use in the OrionRisc-128 system
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        CSemanticAnalyzer,
        CCompiler,
        C_SEMANTIC_ANALYZER_PROGRAM,
        C_SEMANTIC_ANALYZER_ASSEMBLY,
        EXAMPLE_C_CODE_SEMANTIC,
        testCCompilerWithSemanticAnalysis,
        testSemanticAnalyzerWithMockAST,
        validateSemanticAnalysis,
        printSemanticAnalysisResults,
        C_SEMANTIC_ERRORS,
        C_TYPES,
        C_TYPE_MODIFIERS,
        C_SCOPE_LEVELS,
        C_SEMANTIC_STATES,
        SYMBOL_ENTRY_FORMAT
    };
}

module.exports = CSemanticAnalyzer;