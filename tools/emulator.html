<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OrionRisc-128 Emulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .emulator-container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
        }

        .emulator-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #00ffff;
            padding-bottom: 15px;
        }

        .emulator-title {
            font-size: 2.5em;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 10px;
        }

        .emulator-subtitle {
            color: #cccccc;
            font-size: 1.1em;
        }

        .emulator-main {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .display-section {
            flex: 1;
            background: #000000;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #333333;
        }

        .display-container {
            background: #000000;
            border-radius: 8px;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }

        .display-bezel {
            position: relative;
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            border: 3px solid #444444;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }

        .display-screen {
            background: #000000;
            width: 640px;
            height: 200px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border: 1px solid #333333;
        }

        .controls-section {
            width: 300px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #00ffff;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            font-size: 1.1em;
            color: #00ffff;
            margin-bottom: 8px;
            display: block;
        }

        .control-button {
            background: linear-gradient(135deg, #0066cc, #004499);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9em;
            margin: 2px;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            background: linear-gradient(135deg, #0077ee, #0055bb);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 255, 255, 0.3);
        }

        .control-button:active {
            transform: translateY(0);
        }

        .control-button:disabled {
            background: #333333;
            color: #666666;
            cursor: not-allowed;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-running {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .status-stopped {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        .status-paused {
            background: #ffff00;
            box-shadow: 0 0 10px #ffff00;
        }

        .register-display {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .register-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .register-name {
            color: #00ffff;
        }

        .register-value {
            color: #ffffff;
            font-weight: bold;
        }

        .memory-display {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            max-height: 200px;
            overflow-y: auto;
        }

        .memory-address {
            color: #888888;
        }

        .memory-data {
            color: #ffffff;
            margin-left: 10px;
        }

        .file-input {
            margin-top: 8px;
        }

        .file-input input {
            display: none;
        }

        .file-input label {
            background: linear-gradient(135deg, #cc6600, #994400);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9em;
        }

        .file-input label:hover {
            background: linear-gradient(135deg, #ee7700, #bb5500);
        }

        .debug-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #ffff00;
        }

        .debug-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .debug-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            padding: 10px;
        }

        .info-title {
            color: #ffff00;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .info-content {
            color: #ffffff;
            font-size: 0.8em;
            font-family: 'Courier New', monospace;
        }

        .log-panel {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
        }

        .log-entry {
            color: #cccccc;
            margin-bottom: 4px;
        }

        .log-entry.error {
            color: #ff6666;
        }

        .log-entry.warning {
            color: #ffff66;
        }

        .log-entry.info {
            color: #66ff66;
        }

        .footer {
            text-align: center;
            margin-top: 20px;
            color: #888888;
            font-size: 0.9em;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
        }

        .slider-container label {
            min-width: 80px;
            color: #cccccc;
        }

        .slider-container input[type="range"] {
            flex: 1;
            height: 6px;
            background: #333333;
            border-radius: 3px;
            outline: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }

        .checkbox-container input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #00ffff;
        }

        .checkbox-container label {
            color: #cccccc;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .emulator-main {
                flex-direction: column;
            }

            .controls-section {
                width: 100%;
            }

            .display-screen {
                width: 100%;
                height: auto;
                aspect-ratio: 16/5;
            }
        }
    </style>
</head>
<body>
    <div class="emulator-container">
        <div class="emulator-header">
            <h1 class="emulator-title">OrionRisc-128</h1>
            <p class="emulator-subtitle">1980s Style Computer Emulator</p>
        </div>

        <div class="emulator-main">
            <div class="display-section">
                <div class="display-container">
                    <div class="display-bezel">
                        <canvas id="orion-canvas" class="display-screen" width="640" height="200"></canvas>
                    </div>
                </div>
            </div>

            <div class="controls-section">
                <div class="control-group">
                    <div class="control-label">Emulation Controls</div>
                    <button id="btn-start" class="control-button">‚ñ∂Ô∏è Start</button>
                    <button id="btn-stop" class="control-button" disabled>‚èπÔ∏è Stop</button>
                    <button id="btn-reset" class="control-button">üîÑ Reset</button>
                    <button id="btn-step" class="control-button">‚è≠Ô∏è Step</button>
                </div>

                <div class="control-group">
                    <div class="control-label">Speed Control</div>
                    <div class="slider-container">
                        <label for="speed-slider">Speed:</label>
                        <input type="range" id="speed-slider" min="1" max="100" value="50">
                        <span id="speed-value">50%</span>
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-label">Display Options</div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="show-fps" checked>
                        <label for="show-fps">Show FPS</label>
                    </div>
                    <div class="slider-container">
                        <label for="scale-slider">Scale:</label>
                        <input type="range" id="scale-slider" min="1" max="4" value="2">
                        <span id="scale-value">2x</span>
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-label">Program Loading</div>
                    <div class="file-input">
                        <input type="file" id="file-load" accept=".bin,.hex">
                        <label for="file-load">üìÅ Load Program</label>
                    </div>
                    <button id="btn-save" class="control-button">üíæ Save State</button>
                    <button id="btn-load-state" class="control-button">üìÇ Load State</button>
                </div>

                <div class="control-group">
                    <div class="control-label">Processor Status</div>
                    <div class="status-indicator" id="status-indicator"></div>
                    <span id="status-text">Stopped</span>
                </div>

                <div class="control-group">
                    <div class="control-label">Registers</div>
                    <div class="register-display" id="register-display">
                        <!-- Registers will be populated by JavaScript -->
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-label">Memory</div>
                    <div class="memory-display" id="memory-display">
                        <!-- Memory contents will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>

        <div class="debug-section">
            <div class="control-label">Debug Information</div>
            <div class="debug-controls">
                <button id="btn-debug-memory" class="control-button">üìä Memory Dump</button>
                <button id="btn-debug-clear" class="control-button">üóëÔ∏è Clear Log</button>
                <button id="btn-debug-export" class="control-button">üìã Export Log</button>
            </div>

            <div class="debug-info">
                <div class="info-panel">
                    <div class="info-title">Emulation Stats</div>
                    <div class="info-content" id="emulation-stats">
                        <div>Cycles: 0</div>
                        <div>Instructions: 0</div>
                        <div>FPS: 0.0</div>
                        <div>Memory Used: 0%</div>
                    </div>
                </div>

                <div class="info-panel">
                    <div class="info-title">System Status</div>
                    <div class="info-content" id="system-status">
                        <div>Processor: Stopped</div>
                        <div>Graphics: OK</div>
                        <div>Storage: OK</div>
                        <div>I/O: OK</div>
                    </div>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-title">Debug Log</div>
                <div class="log-panel" id="debug-log">
                    <!-- Log entries will be added by JavaScript -->
                </div>
            </div>
        </div>

        <div class="footer">
            <p>OrionRisc-128 Emulator - Built with JavaScript for Educational Purposes</p>
        </div>
    </div>

    <script>
        // OrionRisc-128 Emulator JavaScript (Standalone version to avoid CORS issues)

        // Memory class
        class Memory {
            constructor() {
                this.size = 128 * 1024;
                this.data = new Uint8Array(this.size);
                this.IO_START = 0x1FF00;
                this.IO_SIZE = 256;
                this.clear();
            }

            clear() {
                this.data.fill(0);
            }

            readByte(address) {
                address = address & 0x1FFFF;
                if (address >= this.IO_START && address < this.IO_START + this.IO_SIZE) {
                    return this.readIO(address - this.IO_START);
                }
                return this.data[address];
            }

            writeByte(address, value) {
                address = address & 0x1FFFF;
                value = value & 0xFF;
                if (address >= this.IO_START && address < this.IO_START + this.IO_SIZE) {
                    this.writeIO(address - this.IO_START, value);
                    return;
                }
                this.data[address] = value;
            }

            readWord(address) {
                const addr1 = address & 0x1FFFF;
                const addr2 = (address + 1) & 0x1FFFF;
                const lowByte = this.readByte(addr1);
                const highByte = this.readByte(addr2);
                return (highByte << 8) | lowByte;
            }

            writeWord(address, value) {
                const addr1 = address & 0x1FFFF;
                const addr2 = (address + 1) & 0x1FFFF;
                const lowByte = value & 0xFF;
                const highByte = (value >> 8) & 0xFF;
                this.writeByte(addr1, lowByte);
                this.writeByte(addr2, highByte);
            }

            readIO(offset) {
                return 0;
            }

            writeIO(offset, value) {
                // I/O operations handled by IOManager
            }

            loadProgram(program, startAddress = 0) {
                for (let i = 0; i < program.length; i++) {
                    const address = startAddress + (i * 2);
                    this.writeWord(address, program[i]);
                }
            }

            getStats() {
                let used = 0;
                for (let i = 0; i < this.data.length; i++) {
                    if (this.data[i] !== 0) used++;
                }
                return {
                    total: this.size,
                    used: used,
                    free: this.size - used,
                    usagePercent: (used / this.size) * 100
                };
            }

            hexDump(start = 0, lines = 16) {
                let result = '';
                for (let line = 0; line < lines; line++) {
                    const address = start + (line * 16);
                    if (address >= this.size) break;

                    let lineStr = `${address.toString(16).padStart(5, '0')}: `;

                    for (let i = 0; i < 16; i++) {
                        if (address + i >= this.size) {
                            lineStr += '   ';
                        } else {
                            lineStr += this.data[address + i].toString(16).padStart(2, '0') + ' ';
                        }
                    }

                    lineStr += ' ';
                    for (let i = 0; i < 16; i++) {
                        if (address + i >= this.size) {
                            lineStr += ' ';
                        } else {
                            const byte = this.data[address + i];
                            lineStr += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                        }
                    }

                    result += lineStr + '\n';
                }
                return result;
            }
        }

        // Graphics class
        class Graphics {
            constructor(canvasId = 'orion-canvas') {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    this.canvas = document.createElement('canvas');
                    this.canvas.id = canvasId;
                    this.canvas.width = 640;
                    this.canvas.height = 200;
                    document.body.appendChild(this.canvas);
                }
                this.ctx = this.canvas.getContext('2d');
                this.width = 640;
                this.height = 200;
                this.framebuffer = new Uint8Array(this.width * this.height);
                this.textBuffer = Array(25).fill().map(() => new Uint8Array(80));
                this.colorBuffer = Array(25).fill().map(() => new Uint8Array(80));
                this.cursorX = 0;
                this.cursorY = 0;
                this.currentMode = 0;
                this.clear();
            }

            clear() {
                this.framebuffer.fill(0);
                for (let y = 0; y < 25; y++) {
                    this.textBuffer[y].fill(0x20);
                    this.colorBuffer[y].fill(0x07);
                }
                this.cursorX = 0;
                this.cursorY = 0;
                this.render();
            }

            plotPixel(x, y, color) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    const index = y * this.width + x;
                    this.framebuffer[index] = color & 1;
                }
            }

            getPixel(x, y) {
                if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                    const index = y * this.width + x;
                    return this.framebuffer[index];
                }
                return 0;
            }

            writeChar(char, color = 0x07) {
                if (this.cursorX >= 80) {
                    this.cursorX = 0;
                    this.cursorY++;
                }
                if (this.cursorY >= 25) {
                    this.scrollText();
                    this.cursorY = 24;
                }
                this.textBuffer[this.cursorY][this.cursorX] = char;
                this.colorBuffer[this.cursorY][this.cursorX] = color;
                this.cursorX++;
            }

            writeString(str, color = 0x07) {
                for (let i = 0; i < str.length; i++) {
                    this.writeChar(str.charCodeAt(i), color);
                }
            }

            setCursor(x, y) {
                this.cursorX = Math.max(0, Math.min(79, x));
                this.cursorY = Math.max(0, Math.min(24, y));
            }

            scrollText() {
                for (let y = 1; y < 25; y++) {
                    this.textBuffer[y - 1] = this.textBuffer[y].slice();
                    this.colorBuffer[y - 1] = this.colorBuffer[y].slice();
                }
                this.textBuffer[24].fill(0x20);
                this.colorBuffer[24].fill(0x07);
            }

            render() {
                if (this.currentMode === 0) {
                    this.renderGraphics();
                } else {
                    this.renderText();
                }
            }

            renderGraphics() {
                const imageData = this.ctx.createImageData(this.width, this.height);
                const data = imageData.data;
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const index = y * this.width + x;
                        const pixelIndex = (y * this.width + x) * 4;
                        const color = this.framebuffer[index];
                        data[pixelIndex] = color * 255;
                        data[pixelIndex + 1] = color * 255;
                        data[pixelIndex + 2] = color * 255;
                        data[pixelIndex + 3] = 255;
                    }
                }
                this.ctx.putImageData(imageData, 0, 0);
            }

            renderText() {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.width, this.height);

                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 80; x++) {
                        const charCode = this.textBuffer[y][x];
                        const colorAttr = this.colorBuffer[y][x];
                        const fgColor = colorAttr & 0x0F;
                        const bgColor = (colorAttr >> 4) & 0x0F;

                        this.renderChar(x, y, charCode, fgColor, bgColor);
                    }
                }

                // Render cursor
                if (Math.floor(Date.now() / 500) % 2) {
                    const px = this.cursorX * 8;
                    const py = this.cursorY * 8;
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillRect(px, py + 7, 8, 1);
                }
            }

            renderChar(x, y, charCode, fgColor, bgColor) {
                const px = x * 8;
                const py = y * 8;

                // Draw background
                this.ctx.fillStyle = (bgColor & 1) ? '#FFFFFF' : '#000000';
                this.ctx.fillRect(px, py, 8, 8);

                // Draw character (simplified)
                this.ctx.fillStyle = (fgColor & 1) ? '#FFFFFF' : '#000000';

                if (charCode >= 32 && charCode <= 126) {
                    this.ctx.fillText(String.fromCharCode(charCode), px, py + 7);
                }
            }

            readRegister(reg) {
                switch (reg) {
                    case 0x00: return this.currentMode;
                    case 0x01: return this.cursorX;
                    case 0x02: return this.cursorY;
                    default: return 0;
                }
            }

            writeRegister(reg, value) {
                switch (reg) {
                    case 0x00:
                        this.currentMode = value & 1;
                        break;
                    case 0x01:
                        this.cursorX = value % 80;
                        break;
                    case 0x02:
                        this.cursorY = value % 25;
                        break;
                    case 0x03:
                        this.writeChar(value & 0xFF);
                        break;
                }
            }

            getDimensions() {
                return { width: this.width, height: this.height };
            }
        }

        // Processor class
        class Processor {
            constructor(memory) {
                this.memory = memory;
                this.registers = new Uint16Array(8);
                this.pc = 0;
                this.ir = 0;
                this.flags = { carry: false, overflow: false, zero: false, negative: false };
                this.halted = false;
                this.cycles = 0;

                this.OPCODES = {
                    ADD: 0x00, SUB: 0x01, MUL: 0x02, DIV: 0x03,
                    AND: 0x04, OR: 0x05, XOR: 0x06, NOT: 0x07,
                    LD: 0x08, ST: 0x09, LDI: 0x0A, LDA: 0x0B,
                    JMP: 0x0C, JZ: 0x0D, JNZ: 0x0E, CALL: 0x0F,
                    IN: 0x10, OUT: 0x11, HALT: 0x12, NOP: 0x13
                };
            }

            reset() {
                this.registers.fill(0);
                this.pc = 0;
                this.ir = 0;
                this.flags = { carry: false, overflow: false, zero: false, negative: false };
                this.halted = false;
                this.cycles = 0;
            }

            step() {
                if (this.halted) return false;

                this.ir = this.memory.readWord(this.pc);
                this.pc += 2;
                this.cycles++;

                return this.executeInstruction(this.ir);
            }

            executeInstruction(instruction) {
                const opcode = (instruction >> 12) & 0xF;
                const rd = (instruction >> 9) & 0x7;
                const rs = (instruction >> 6) & 0x7;
                const imm = instruction & 0x3F;

                switch (opcode) {
                    case this.OPCODES.ADD:
                        const rsValAdd = this.registers[rs];
                        const resultAdd = rsValAdd + imm;
                        this.registers[rd] = resultAdd & 0xFFFF;
                        this.updateFlags(resultAdd);
                        break;

                    case this.OPCODES.SUB:
                        const rsValSub = this.registers[rs];
                        const resultSub = rsValSub - imm;
                        this.registers[rd] = resultSub & 0xFFFF;
                        this.updateFlags(resultSub);
                        break;

                    case this.OPCODES.LD:
                        const addressLd = (this.registers[rs] + imm) & 0x1FFFF;
                        this.registers[rd] = this.memory.readWord(addressLd);
                        break;

                    case this.OPCODES.ST:
                        const addressSt = (this.registers[rd] + imm) & 0x1FFFF;
                        this.memory.writeWord(addressSt, this.registers[rs]);
                        break;

                    case this.OPCODES.LDI:
                        const signedImm = (imm & 0x20) ? (imm | 0xFFC0) : (imm & 0x3F);
                        this.registers[rd] = signedImm;
                        this.updateFlags(signedImm);
                        break;

                    case this.OPCODES.JMP:
                        this.pc = imm;
                        break;

                    case this.OPCODES.JZ:
                        if (this.flags.zero) {
                            this.pc = imm;
                        }
                        break;

                    case this.OPCODES.HALT:
                        this.halted = true;
                        return false;

                    case this.OPCODES.NOP:
                        break;

                    default:
                        throw new Error(`Unknown opcode: 0x${opcode.toString(16)}`);
                }

                return true;
            }

            updateFlags(result) {
                this.flags.carry = (result > 0xFFFF) || (result < 0);
                this.flags.overflow = (result > 0x7FFF) || (result < -0x8000);
                this.flags.zero = (result & 0xFFFF) === 0;
                this.flags.negative = (result & 0x8000) !== 0;
            }

            getState() {
                return {
                    registers: Array.from(this.registers),
                    pc: this.pc,
                    ir: this.ir,
                    flags: {...this.flags},
                    halted: this.halted,
                    cycles: this.cycles
                };
            }
        }

        // Main Emulator class
        class OrionEmulator {
            constructor() {
                this.processor = null;
                this.memory = null;
                this.graphics = null;

                this.running = false;
                this.animationId = null;
                this.lastFrameTime = 0;
                this.frameCount = 0;
                this.fps = 0;

                this.speedMultiplier = 50;
                this.debugLog = [];

                this.initializeComponents();
                this.setupEventListeners();
                this.updateDisplay();
            }

            initializeComponents() {
                try {
                    this.memory = new Memory();
                    this.graphics = new Graphics('orion-canvas');
                    this.processor = new Processor(this.memory);

                    this.log('System initialized successfully', 'info');
                } catch (error) {
                    this.log(`Initialization error: ${error.message}`, 'error');
                    console.error('Emulator initialization failed:', error);
                }
            }

            setupEventListeners() {
                document.getElementById('btn-start').addEventListener('click', () => this.start());
                document.getElementById('btn-stop').addEventListener('click', () => this.stop());
                document.getElementById('btn-reset').addEventListener('click', () => this.reset());
                document.getElementById('btn-step').addEventListener('click', () => this.step());

                const speedSlider = document.getElementById('speed-slider');
                const speedValue = document.getElementById('speed-value');
                speedSlider.addEventListener('input', (e) => {
                    this.speedMultiplier = parseInt(e.target.value);
                    speedValue.textContent = `${this.speedMultiplier}%`;
                });

                const scaleSlider = document.getElementById('scale-slider');
                const scaleValue = document.getElementById('scale-value');
                scaleSlider.addEventListener('input', (e) => {
                    const scale = parseInt(e.target.value);
                    scaleValue.textContent = `${scale}x`;
                    this.graphics.canvas.style.width = `${640 * scale}px`;
                    this.graphics.canvas.style.height = `${200 * scale}px`;
                });

                document.getElementById('file-load').addEventListener('change', (e) => {
                    this.loadProgramFile(e.target.files[0]);
                });

                document.getElementById('btn-debug-memory').addEventListener('click', () => {
                    this.showMemoryDump();
                });

                document.getElementById('btn-debug-clear').addEventListener('click', () => {
                    this.clearDebugLog();
                });

                document.getElementById('btn-debug-export').addEventListener('click', () => {
                    this.exportDebugLog();
                });
            }

            start() {
                if (this.running) return;

                this.running = true;
                this.lastFrameTime = performance.now();

                this.updateButtons();
                this.log('Emulation started', 'info');

                this.emulationLoop();
            }

            stop() {
                if (!this.running) return;

                this.running = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }

                this.updateButtons();
                this.log('Emulation stopped', 'info');
            }

            reset() {
                this.stop();

                if (this.processor) {
                    this.processor.reset();
                }

                if (this.memory) {
                    this.memory.clear();
                }

                if (this.graphics) {
                    this.graphics.clear();
                }

                this.log('System reset', 'info');
                this.updateDisplay();
            }

            step() {
                if (this.running) return;

                try {
                    if (this.processor && this.processor.step()) {
                        this.updateDisplay();
                    }
                } catch (error) {
                    this.log(`Step error: ${error.message}`, 'error');
                }
            }

            emulationLoop() {
                if (!this.running) return;

                const now = performance.now();
                const deltaTime = now - this.lastFrameTime;

                this.frameCount++;
                if (deltaTime >= 1000) {
                    this.fps = (this.frameCount * 1000) / deltaTime;
                    this.frameCount = 0;
                    this.lastFrameTime = now;
                }

                if (this.processor) {
                    const instructionsPerFrame = Math.max(1, Math.floor((this.speedMultiplier / 100) * 1000));

                    for (let i = 0; i < instructionsPerFrame && this.running; i++) {
                        try {
                            if (!this.processor.step()) {
                                this.stop();
                                break;
                            }
                        } catch (error) {
                            this.log(`Runtime error: ${error.message}`, 'error');
                            this.stop();
                            break;
                        }
                    }
                }

                this.updateDisplay();
                this.animationId = requestAnimationFrame(() => this.emulationLoop());
            }

            updateDisplay() {
                this.updateRegisters();
                this.updateMemory();
                this.updateStatus();
                this.updateStats();
                if (this.graphics) {
                    this.graphics.render();
                }
            }

            updateButtons() {
                const startBtn = document.getElementById('btn-start');
                const stopBtn = document.getElementById('btn-stop');
                const stepBtn = document.getElementById('btn-step');

                startBtn.disabled = this.running;
                stopBtn.disabled = !this.running;
                stepBtn.disabled = this.running;
            }

            updateRegisters() {
                if (!this.processor) return;

                const state = this.processor.getState();
                const registerDisplay = document.getElementById('register-display');

                let html = '';
                for (let i = 0; i < 8; i++) {
                    html += `
                        <div class="register-row">
                            <span class="register-name">R${i}:</span>
                            <span class="register-value">0x${state.registers[i].toString(16).padStart(4, '0')}</span>
                        </div>
                    `;
                }

                html += `
                    <div class="register-row">
                        <span class="register-name">PC:</span>
                        <span class="register-value">0x${state.pc.toString(16).padStart(4, '0')}</span>
                    </div>
                    <div class="register-row">
                        <span class="register-name">Flags:</span>
                        <span class="register-value">${state.flags.zero ? 'Z' : '.'}${state.flags.carry ? 'C' : '.'}${state.flags.overflow ? 'O' : '.'}${state.flags.negative ? 'N' : '.'}</span>
                    </div>
                `;

                registerDisplay.innerHTML = html;
            }

            updateMemory() {
                if (!this.memory) return;

                const memoryDisplay = document.getElementById('memory-display');
                const startAddress = 0x0000;

                let html = '';
                for (let i = 0; i < 16; i++) {
                    const address = startAddress + (i * 8);
                    if (address >= 0x20000) break;

                    html += `
                        <div style="margin-bottom: 4px;">
                            <span class="memory-address">${address.toString(16).padStart(4, '0')}:</span>
                    `;

                    for (let j = 0; j < 8; j++) {
                        const addr = address + j;
                        const value = this.memory.readByte(addr);
                        html += `<span class="memory-data">${value.toString(16).padStart(2, '0')}</span> `;
                    }

                    html += '</div>';
                }

                memoryDisplay.innerHTML = html;
            }

            updateStatus() {
                const statusIndicator = document.getElementById('status-indicator');
                const statusText = document.getElementById('status-text');

                if (this.running) {
                    statusIndicator.className = 'status-indicator status-running';
                    statusText.textContent = 'Running';
                } else {
                    statusIndicator.className = 'status-indicator status-stopped';
                    statusText.textContent = 'Stopped';
                }
            }

            updateStats() {
                if (!this.processor || !this.memory) return;

                const stats = this.memory.getStats();
                const emulationStats = document.getElementById('emulation-stats');

                emulationStats.innerHTML = `
                    <div>Cycles: ${this.processor.cycles}</div>
                    <div>Instructions: ${Math.floor(this.processor.cycles)}</div>
                    <div>FPS: ${this.fps.toFixed(1)}</div>
                    <div>Memory Used: ${stats.usagePercent.toFixed(1)}%</div>
                `;
            }

            loadProgramFile(file) {
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        const programData = new Uint8Array(arrayBuffer);

                        if (programData.length % 2 !== 0) {
                            this.log('Warning: Program data length is not even, padding with zero', 'warning');
                        }

                        const program = new Uint16Array(programData.length / 2);
                        for (let i = 0; i < program.length; i++) {
                            const lowByte = programData[i * 2] || 0;
                            const highByte = programData[(i * 2) + 1] || 0;
                            program[i] = (highByte << 8) | lowByte;
                        }

                        if (this.memory) {
                            this.memory.loadProgram(program);
                            this.log(`Program loaded: ${program.length} words`, 'info');
                            this.updateDisplay();
                        }
                    } catch (error) {
                        this.log(`Failed to load program: ${error.message}`, 'error');
                    }
                };

                reader.readAsArrayBuffer(file);
            }

            showMemoryDump() {
                if (!this.memory) return;

                const dump = this.memory.hexDump(0, 256);
                this.log(`Memory dump (0x0000-0x00FF):\n${dump}`, 'info');
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const entry = { timestamp, message, type };
                this.debugLog.unshift(entry);

                if (this.debugLog.length > 100) {
                    this.debugLog = this.debugLog.slice(0, 100);
                }

                this.updateDebugLogDisplay();
            }

            updateDebugLogDisplay() {
                const debugLog = document.getElementById('debug-log');

                let html = '';
                for (const entry of this.debugLog.slice(0, 20)) {
                    html += `<div class="log-entry ${entry.type}">[${entry.timestamp}] ${entry.message}</div>`;
                }

                debugLog.innerHTML = html;
                debugLog.scrollTop = 0;
            }

            clearDebugLog() {
                this.debugLog = [];
                this.updateDebugLogDisplay();
            }

            exportDebugLog() {
                const logText = this.debugLog.map(entry =>
                    `[${entry.timestamp}] ${entry.message}`
                ).join('\n');

                const blob = new Blob([logText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `orion-emulator-log-${new Date().toISOString().slice(0, 19)}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // Initialize emulator when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.orionEmulator = new OrionEmulator();
        });
    </script>
</body>
</html>